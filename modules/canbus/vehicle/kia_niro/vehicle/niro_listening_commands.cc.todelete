#include <errno.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <signal.h>
#include <sys/time.h>
#include <fcntl.h>

#include "oscc.h"
#include "commander.h"
#include "can_protocols/steering_can_protocol.h"

#include "modules/oscc_jscmd/proto/oscc.pb.h"

#include "cyber/cyber.h"
#include "cyber/time/rate.h"
#include "cyber/time/time.h"

#define COMMANDER_UPDATE_INTERVAL_MICRO (50000)
#define SLEEP_TICK_INTERVAL_MICRO (1000)

using apollo::cyber::Rate;
using apollo::cyber::Time;
using apollo::modules_syn::oscc_jscmd::proto::NiroStatus;

// double g_steering_angle = 0.0;
// double g_steering_angle = 0.0;
// int g_channel;
// double g_brake_pressure = 3.0;
// double g_steering_angle = 2.0;

static int error_thrown = OSCC_OK;

void signal_handler(int signal_number)
{
  if (signal_number == SIGINT)
    error_thrown = OSCC_ERROR;
}

int main(int argc, char** argv) 
{
  oscc_result_t result = OSCC_OK;
  // unsigned long long update_timestamp = get_timestamp_micro();
  // unsigned long long elapsed_time = 0;
  int can_hannel = 0;
  errno = 0;
  if (argc!=2 || (channel=atoi(argv[1]), errno)!=0)
  {
    printf("usage %s channel\n", argv[0]);
    exit(1);
  }
  channel = 1; // can1 
  // g_channel = channel;

  struct sigaction sig;
  sig.sa_handler = signal_handler;
  sigaction(SIGINT, &sig, NULL);
  ret = commander_init(can_channel);

  // init cyber framework
  apollo::cyber::Init(argv[0]);
  // create talker node
  // auto talker_node = apollo::cyber::CreateNode("niro_status");
  // create talker
  // auto talker = talker_node->CreateWriter<NiroStatus>("oscc/niro_status");
  double frequency = 32;
  Rate rate(frequency);
  uint64_t seq = 0;
  while (apollo::cyber::OK()) {
    auto msg = std::make_shared<NiroStatus>();
    msg->set_timestamp(Time::Now().ToNanosecond());
    msg->set_seq(seq);
    msg->set_steering_angle(g_steering_angle);
    msg->set_brake_pressure(g_brake_pressure);
    talker->Write(msg);
    AINFO << "Sent a status message from Niro to Apollo! No. " << seq;
    seq++;
    rate.Sleep();
  }
  return 0;
}
